//@ sourceMappingURL=.map
// Generated by CoffeeScript 1.6.1

/*
* Editor Class: Contains the code for defining a custom text editor
* and calculator hybrid.
*/


(function() {
  var FONTWIDTH, LINEHEIGHT, LINEWIDTH, addLine, adjustHighlightIndices, convertUnits, currentindex, currentline, fitToWindow, getDecimalVal, getLineDiv, getLineLength, getLineNumDiv, getMouseLoc, getOutLineDiv, highlightData, isHighlightStartGreater, isHighlighted, isLastLine, keydownfunc, keys, keyupfunc, moveCursor, offset, removeHighlight, removeHighlightedSection, removeLine, root, trimZeros,
    _this = this,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  LINEWIDTH = 50;

  FONTWIDTH = 11;

  LINEHEIGHT = 25;

  currentline = 0;

  currentindex = 0;

  highlightData = [];

  calcFramework.setLineWidth(LINEWIDTH);

  calcFramework.restoreFromStorage();

  ko.applyBindings(calcFramework);

  $(document).unbind("keydown").bind("keydown", function(event) {
    var doPrevent;
    doPrevent = false;
    if (event.keyCode === 8) {
      return event.preventDefault();
    }
  });

  $("#in").on("mouseup", ".inln", function(e) {
    var loc;
    loc = getMouseLoc(e);
    highlightData[2] = loc.line;
    highlightData[3] = loc.position;
    adjustHighlightIndices();
    return moveCursor(highlightData[2], highlightData[3]);
  });

  $("#in").on("mousedown", ".inln", function(e) {
    var loc;
    loc = getMouseLoc(e);
    highlightData[0] = loc.line;
    return highlightData[1] = loc.position;
  });

  getMouseLoc = function(e) {
    var column, linelength, lineoffset, newline, pos, xdiff, xpos, ydiff, ypos;
    newline = $(e.currentTarget).data("line");
    lineoffset = $(e.currentTarget).offset();
    linelength = getLineLength(newline);
    xpos = e.pageX;
    ypos = e.pageY;
    xdiff = xpos - lineoffset.left;
    ydiff = ypos - lineoffset.top;
    column = xdiff / FONTWIDTH + Math.floor(ydiff / LINEHEIGHT) * LINEWIDTH;
    pos = Math.min(linelength, column);
    return {
      line: newline,
      position: pos
    };
  };

  adjustHighlightIndices = function() {
    var bigStart, endhalfway, h3;
    bigStart = isHighlightStartGreater();
    endhalfway = highlightData[3] % 1 < 0.5;
    highlightData[1] = Math.floor(highlightData[1]);
    h3 = highlightData[3];
    return highlightData[3] = bigStart || endhalfway ? Math.floor(h3) : Math.ceil(h3);
  };

  $(document).keydown(function(e) {
    var cline, input, moveLine, prevlength, prevline, registered, remains;
    cline = calcFramework.getLine(currentline);
    input = cline.input();
    registered = true;
    switch (e.keyCode) {
      case 8:
        if (isHighlighted()) {
          removeHighlightedSection();
          break;
        }
        if (currentindex > 0) {
          cline.input(input.splice(currentindex - 1, 1));
          moveCursor(currentline, currentindex - 1);
        } else if (currentline > 0) {
          prevline = calcFramework.getLine(currentline - 1);
          prevlength = prevline.input().length;
          prevline.input(prevline.input() + cline.input());
          removeLine(currentline);
          moveCursor(currentline - 1, prevlength);
        }
        break;
      case 13:
        if (isHighlighted()) {
          removeHighlightedSection();
          cline = calcFramework.getLine(currentline);
          input = cline.input();
        }
        remains = input.substring(currentindex);
        cline.input(input.substring(0, currentindex));
        addLine(currentline + 1);
        cline = calcFramework.getLine(currentline + 1);
        cline.input(remains);
        moveCursor(currentline + 1, 0);
        break;
      case 32:
        cline.input(input.splice(currentindex, 0, " "));
        moveCursor(currentline, currentindex + 1);
        break;
      case 35:
        e.preventDefault();
        moveLine = e.ctrlKey ? calcFramework.getNumLines() : currentline;
        moveCursor(moveLine, calcFramework.getLine(moveLine).input().length);
        break;
      case 36:
        e.preventDefault();
        moveLine = e.ctrlKey ? 1 : currentline;
        moveCursor(moveLine, 0);
        break;
      case 37:
        if (currentindex === 0) {
          if (currentline > 0) {
            moveCursor(currentline - 1);
          }
        } else {
          moveCursor(currentline, currentindex - 1);
        }
        break;
      case 38:
        if (currentline > 0) {
          moveCursor(currentline - 1, currentindex);
        }
        break;
      case 39:
        if (currentindex === getLineLength(currentline)) {
          if (!isLastLine) {
            moveCursor(currentline + 1, 0);
          }
        } else {
          moveCursor(currentline, currentindex + 1);
        }
        break;
      case 40:
        if (!isLastLine(currentline)) {
          moveCursor(currentline + 1, currentindex);
        }
        break;
      case 46:
        if (isHighlighted()) {
          removeHighlightedSection();
          break;
        }
        if (currentindex === getLineLength(currentline)) {
          if (!isLastLine(currentline)) {
            calcFramework.appendNextLine(currentline);
          } else {
            cline.input(cline.input().splice(currentindex, 1));
          }
        }
        break;
      default:
        registered = false;
    }
    if (registered) {
      removeHighlight();
    }
    return setTimeout(0, calcFramework.saveToStorage());
  });

  $(document).keypress(function(e) {
    var cline, input, keyVal;
    if (e.keyCode === 13) {
      return null;
    }
    cline = calcFramework.getLine(currentline);
    input = cline.input();
    keyVal = String.fromCharCode(e.keyCode);
    if (!e.shiftKey) {
      keyVal = keyVal.toLowerCase();
    }
    if (isHighlighted()) {
      removeHighlightedSection(keyVal);
    } else {
      cline.input(input.splice(currentindex, 0, keyVal));
      moveCursor(currentline, currentindex + 1);
    }
    return setTimeout(0, calcFramework.saveToStorage());
  });

  getLineLength = function(index) {
    var line;
    line = calcFramework.getLine(index);
    return line.input().length;
  };

  isLastLine = function(linenum) {
    return linenum === calcFramework.getNumLines() - 1;
  };

  getLineDiv = function(linenum) {
    return $(".inln").filter(function() {
      return this.getAttribute("data-line") === linenum + "";
    });
  };

  getOutLineDiv = function(linenum) {
    return $(".outln").filter(function() {
      return this.getAttribute("data-line") === linenum + "";
    });
  };

  getLineNumDiv = function(linenum) {
    return $(".linenum").filter(function() {
      return this.getAttribute("data-line") === linenum + "";
    });
  };

  removeLine = function(line) {
    return calcFramework.removeLine(line);
  };

  addLine = function(line) {
    return calcFramework.addLine(line);
  };

  isHighlighted = function() {
    var hd, samepoints;
    hd = highlightData;
    samepoints = hd[0] === hd[2] && hd[1] === hd[3];
    return hd.length > 0 && !samepoints;
  };

  removeHighlight = function() {
    highlightData = [];
    return window.getSelection().collapse();
  };

  removeHighlightedSection = function(replacement) {
    var firstindex, firstline, firstremainder, firstsub, i, input, lastindex, lastline, lastremainder, line, secondsub, startGreater, _i;
    if (!replacement) {
      replacement = "";
    }
    startGreater = isHighlightStartGreater();
    lastline = startGreater ? highlightData[0] : highlightData[2];
    lastindex = startGreater ? highlightData[1] : highlightData[3];
    firstline = startGreater ? highlightData[2] : highlightData[0];
    firstindex = startGreater ? highlightData[3] : highlightData[1];
    if (lastline > firstline) {
      lastremainder = calcFramework.getLine(lastline).input().substring(lastindex);
      firstremainder = calcFramework.getLine(firstline).input().substring(0, firstindex);
      for (i = _i = lastline; _i >= firstline; i = _i += -1) {
        removeLine(i);
      }
      firstline = calcFramework.getLine(firstline);
      firstline.input(firstremainder + replacement + lastremainder);
    } else {
      line = calcFramework.getLine(lastline);
      input = line.input();
      firstsub = input.substring(0, firstindex);
      secondsub = input.substring(lastindex);
      line.input(firstsub + replacement + secondsub);
    }
    moveCursor(firstline, firstindex + replacement.length);
    return removeHighlight();
  };

  isHighlightStartGreater = function() {
    var h0, h1, h2, h3;
    h0 = highlightData[0], h1 = highlightData[1], h2 = highlightData[2], h3 = highlightData[3];
    return (h0 > h2) || ((h0 === h2) && (h1 > h3));
  };

  moveCursor = function(line, index) {
    var cursorOffset, extralength, foldnum, inputBottom, inputTop, lineLength, lineOffset, numlines, perceivedIndex;
    numlines = calcFramework.getNumLines();
    if (line > numlines) {
      line = numlines;
      index = null;
    }
    lineLength = getLineLength(line);
    if ((index == null) || index > lineLength) {
      index = lineLength;
    }
    if (line !== currentline) {
      getLineDiv(currentline).removeClass("currentline");
      getLineNumDiv(currentline).removeClass("currentnum");
      getOutLineDiv(currentline).removeClass("currentout");
      getLineDiv(line).addClass("currentline");
      getLineNumDiv(line).addClass("currentnum");
      getOutLineDiv(line).addClass("currentout");
    }
    currentline = line;
    currentindex = index;
    calcFramework.setCurrentLine(line);
    foldnum = Math.floor(index / calcFramework.getLineWidth());
    perceivedIndex = index % calcFramework.getLineWidth();
    lineOffset = getLineDiv(line).offset();
    cursorOffset = {
      top: lineOffset.top + LINEHEIGHT * foldnum,
      left: lineOffset.left + (FONTWIDTH * perceivedIndex)
    };
    inputBottom = $("#in").offset().top + $("#in").height();
    inputTop = $("#in").offset().top;
    extralength = 1;
    if (cursorOffset.top >= inputBottom) {
      extralength = cursorOffset.top - inputBottom;
      $("#in").scrollTop($("#in").scrollTop() + extralength + LINEHEIGHT);
      moveCursor(line, index);
      return null;
    }
    if (cursorOffset.top < inputTop) {
      extralength = inputTop - cursorOffset.top;
      $("#in").scrollTop($("#in").scrollTop() - extralength - LINEHEIGHT);
      moveCursor(line, index);
      return null;
    }
    return $(".cursor").offset(cursorOffset);
  };

  moveCursor(0, 0);

  fitToWindow = function() {
    var inwidth, outwidth;
    inwidth = $(".snapped").width() - $("#out").width() - $("#nums").width();
    $(".inln").width(inwidth);
    LINEWIDTH = Math.floor(inwidth / FONTWIDTH);
    outwidth = Math.floor($("#out").width() / FONTWIDTH);
    calcFramework.setLineWidth(LINEWIDTH);
    calcFramework.setOutWidth(outwidth);
    return moveCursor(currentline, currentindex);
  };

  $(window).resize(fitToWindow);

  fitToWindow();

  $("#in").on("scroll", function() {
    $("#out").scrollTop($(this).scrollTop());
    return $("#nums").scrollTop($(this).scrollTop());
  });

  offset = $("#in").offset();

  $(".cursor").offset(offset);

  keys = [];

  keydownfunc = function(e) {
    keys[e.keyCode] = true;
    switch (e.keyCode) {
      case 8:
      case 37:
      case 39:
      case 38:
      case 40:
      case 32:
        return e.preventDefault();
    }
  };

  keyupfunc = function(e) {
    return keys[e.keyCode] = false;
  };

  window.addEventListener("keydown", keydownfunc, false);

  window.addEventListener("keyup", keyupfunc, false);

  /*
   * markupGen - generates the syntax highlighting for the calculator
   * 
   *
   * @author Ben McCormick
  */


  window.markupGen = (function() {
    var currentVarFunc, mG, returnTextValue;
    mG = {};
    currentVarFunc = function() {
      return null;
    };
    mG.markup = function(expression, getVar) {
      var output;
      currentVarFunc = getVar;
      output = expression.replace(/\s/g, "&nbsp;");
      output = output.replace(/[\+\-\*\/!%\^|,\[\]!#\=]/g, "<span class=\"operator\">$&</span>").replace(/\b\d+/g, "<span class=\"number\">$&</span>").replace(/\w*\(/g, "<span class=\"function\">$&</span>").replace(/\)/g, "<span class=\"function\">$&</span>").replace(/[a-zA-Z]+\d*/g, returnTextValue);
      return output;
    };
    returnTextValue = function(text) {
      var vartext;
      vartext = "<span class=\"variable\">" + text + "</span>";
      if (currentVarFunc(text, false)) {
        return vartext;
      } else {
        return text;
      }
    };
    return mG;
  })();

  String.prototype.chunk = function(n) {
    var i, ret, _i, _ref;
    ret = [];
    for (i = _i = 0, _ref = this.length; n > 0 ? _i <= _ref : _i >= _ref; i = _i += n) {
      ret.push(this.substr(i, n));
    }
    return ret;
  };

  String.prototype.splice = function(idx, rem, extras) {
    extras = extras != null ? extras : "";
    return this.slice(0, idx) + extras + this.slice(idx + Math.abs(rem));
  };

  window.getArrayTotal = function(arr) {
    var total;
    total = 0;
    arr.forEach(function(num) {
      var _ref;
      return total += (_ref = parseFloat(num, 25)) != null ? _ref : 0;
    });
    return total;
  };

  /*
   * calcFramework - An abstract representation of the scratch document as a whole
   * Uses knockout.js bindings to connect data to GUI
   * @author Ben McCormick
  */


  window.calcFramework = (function() {
    var Line, cF, formatErrorMessage, formatted, line1, outputFunction;
    EQParser.init();
    cF = {};
    cF.outputs = ko.observableArray();
    cF.outputs.push(0);
    cF.varMap = {};
    cF.type = "Total";
    cF.lineWidth = ko.observable(50);
    cF.outWidth = ko.observable(25);
    Line = (function() {

      function Line(linenum, currline) {
        var self;
        self = this;
        this.varMap = {};
        this.subscriptions = {};
        this.input = ko.observable("");
        this.subscriptionHandler = function(event, linenum) {
          if (self.linenum() > linenum) {
            return self.trigger(true);
          }
        };
        this.formattedInput = ko.computed({
          read: function() {
            return formatted(self);
          },
          write: function() {},
          owner: self
        });
        this.linenum = ko.observable(linenum);
        this.errormessage = ko.observable();
        this.isCurrentLine = ko.observable(currline != null ? currline : false);
        this.trigger = ko.observable(false);
        this.adjlinenum = ko.computed({
          read: function() {
            return self.linenum() + 1;
          },
          write: function() {},
          owner: self
        });
        this.lnOutput = ko.computed({
          read: function() {
            var result;
            self.unsubscribe();
            result = outputFunction(self, self.input(), self.trigger());
            self.trigger(false);
            return result;
          },
          write: function() {},
          owner: self
        });
        this.lineheight = ko.computed({
          read: function() {
            return (Math.ceil(Math.max(self.input().length / cF.lineWidth(), self.lnOutput().split("<br>").length)) | 0) * 25 + "";
          },
          write: function() {},
          owner: self
        });
      }

      Line.prototype.addPreviousAnswerHandling = function() {
        var ans, exc, isoperator, opers;
        ans = this.linenum() > 1 ? cF.varMap["line" + (this.linenum() - 1)] : new NumberValue(0);
        this.varMap["ans"] = ans;
        opers = /^\s*[\+\-\*\/!%\^&|]/;
        isoperator = opers.exec(this.input);
        if (isoperator && this.input().length && this.linenum() > 1) {
          this.input(this.input().splice(0, 0, "ans "));
          exc = {
            type: "movecursor",
            xdistance: 4,
            ydistance: 0
          };
          throw exc;
        }
      };

      Line.prototype.getVar = function(varName, subscribe, notCurrentLine) {
        var nextLine;
        if (varName == null) {
          return null;
        }
        if (subscribe) {
          this.subscribe(varName);
        }
        if (varName in this.varMap && notCurrentLine) {
          return this.varMap[varName];
        }
        if (this.linenum() > 0) {
          nextLine = cF.lines()[this.linenum() - 1];
          return nextLine != null ? nextLine.getVar(varName, false, true) : void 0;
        } else {
          return cF.varMap[varName];
        }
      };

      Line.prototype.setVar = function(varName, value) {
        this.varMap[varName] = value;
        return this.publish(varName);
      };

      Line.prototype.publish = function(varName) {
        var pub, that;
        that = this;
        pub = function() {
          return $(window).trigger(varName + "event", that.linenum());
        };
        return setTimeout(pub, 0);
      };

      Line.prototype.subscribe = function(varName) {
        if (!(varName in this.subscriptions)) {
          $(window).bind(varName + "event", this.subscriptionHandler);
          return this.subscriptions[varName] = this.subscriptionHandler;
        }
      };

      Line.prototype.unsubscribe = function() {
        var handle, varName, _ref;
        _ref = this.subscriptions;
        for (varName in _ref) {
          handle = _ref[varName];
          $(window).unbind(varName + "event", handle);
        }
        return this.subscriptions = {};
      };

      return Line;

    })();
    outputFunction = function(self, input) {
      var linenum, out;
      try {
        self.addPreviousAnswerHandling();
      } catch (movecursor) {
        return "movecursor";
      }
      try {
        self.errormessage(null);
        out = EQParser.parse(input, 10, self);
        cF.outputs.splice(self.linenum(), 1, out);
        linenum = "line" + self.adjlinenum();
        cF.varMap[linenum] = out;
        return out.toString().chunk(cF.outWidth()).join("<br>");
      } catch (ex) {
        cF.outputs.splice(self.linenum(), 1, 0);
        self.errormessage(formatErrorMessage(ex, self.adjlinenum()));
        return "";
      }
    };
    formatted = function(line) {
      var getVar, output;
      getVar = line.getVar.bind(line);
      output = line.input().chunk(cF.lineWidth()).join("<br>");
      return markupGen.markup(output, getVar);
    };
    formatErrorMessage = function(exception, linenum) {
      return "Line #" + linenum + ":" + exception.message;
    };
    line1 = new Line(0, true);
    cF.lines = ko.observableArray();
    cF.lines.push(line1);
    cF.currentLine = cF.lines()[0];
    cF.getLine = function(index) {
      return cF.lines()[index];
    };
    cF.addLine = function(index) {
      var i, line, newLine, _i, _len, _ref, _results;
      newLine = new Line(index);
      if ((index == null) || (index >= cF.lines().length)) {
        return cF.lines.push(newLine);
      } else {
        cF.lines.splice(index, 0, newLine);
        _ref = cF.lines();
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          line = _ref[i];
          if (i > index) {
            _results.push(line.linenum(line.linenum() + 1));
          }
        }
        return _results;
      }
    };
    cF.removeLine = function(index) {
      var i, line, newLine, _i, _len, _ref, _results;
      newLine = new Line(index);
      if ((index != null) && (index <= cF.lines().length)) {
        cF.lines()[index].unsubscribe();
        cF.lines.splice(index, 1);
        _ref = cF.lines();
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          line = _ref[i];
          if (i >= index) {
            _results.push(line.linenum(line.linenum() - 1));
          }
        }
        return _results;
      }
    };
    cF.appendNextLine = function(index) {
      var line2;
      line1 = cF.lines()[index];
      line2 = cF.lines()[index + 1];
      line1.input(line1.input() + line2.input());
      return cF.removeLine(index + 1);
    };
    cF.setLineWidth = function(width) {
      return cF.lineWidth(width);
    };
    cF.setOutWidth = function(width) {
      return cF.outWidth(width);
    };
    cF.getLineWidth = function() {
      return cF.lineWidth();
    };
    cF.getLineHeight = function(linenum) {
      var _ref;
      return (_ref = cF.lines()[linenum].length / cF.lineWidth()) != null ? _ref : 0;
    };
    cF.getNumLines = function() {
      return cF.lines().length;
    };
    cF.setCurrentLine = function(newCurrentLine) {
      cF.currentLine.isCurrentLine(false);
      cF.currentLine = cF.lines()[newCurrentLine];
      return cF.currentLine.isCurrentLine(true);
    };
    cF.saveToStorage = function() {
      var inputArray, line, _i, _len, _ref;
      inputArray = [];
      _ref = cF.lines();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        inputArray.push(line.input());
      }
      return localStorage["calcInputs"] = JSON.stringify(inputArray);
    };
    cF.restoreFromStorage = function() {
      var i, line, numlines, storageObj, storageString, _i, _len, _results;
      storageString = localStorage["calcInputs"];
      if (storageString == null) {
        return;
      }
      storageObj = JSON.parse(storageString);
      numlines = cF.getNumLines();
      _results = [];
      for (i = _i = 0, _len = storageObj.length; _i < _len; i = ++_i) {
        line = storageObj[i];
        if (i >= numlines) {
          cF.addLine(i);
        }
        _results.push(cF.lines()[i].input(line));
      }
      return _results;
    };
    cF.getAggregate = ko.computed({
      read: function() {
        switch (cF.type) {
          case "Total":
            return getArrayTotal(cF.outputs());
          case "Average":
            return getArrayTotal(cF.outputs()) / cF.outputs().length;
          default:
            return 0;
        }
      },
      write: function() {},
      owner: this
    });
    cF.showLine = function(element) {
      return $(element).filter("div").slideDown();
    };
    cF.hideLine = function(element) {
      return $(element).filter("div").slideUp();
    };
    return cF;
  })();

  /*
   EQParser - An Equation Parser for Javascript
   @author Ben McCormick
  */


  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.EQParser = (function() {
    var EQP, errorInfo, result, unitMap, varMap;
    EQP = {};
    errorInfo = tablePlaceHolder.errors;
    unitMap = tablePlaceHolder.units;
    varMap = {
      "pi": new NumberValue("3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679")
    };
    result = {};
    EQP.init = function() {
      EQTokenizer.init(unitMap);
      EQTreeBuilder.init(unitMap);
      return EQScanner.init(varMap, unitMap);
    };
    EQP.parse = function(expression, precision, currentLine) {
      var getVar, tokenException, tokens;
      getVar = currentLine != null ? currentLine.getVar.bind(currentLine) : function() {
        return null;
      };
      tokens = EQTokenizer.tokenize("#" + expression + "#", getVar);
      if (tokens == null) {
        tokenException = {
          message: errorInfo[3].message,
          type: errorInfo[3].type,
          errorcode: "E03"
        };
        throw tokenException;
      }
      if (precision != null) {
        EQP.setPrecision(precision);
      }
      EQScanner.newExpression(tokens);
      try {
        result = EQTreeBuilder.process(EQScanner, currentLine);
        if (result == null) {
          return "";
        }
        return result.value();
      } catch (ex) {
        throw ex;
      }
    };
    EQP.setPrecision = function(prec) {
      return EQTreeBuilder.setPrecision(prec);
    };
    EQP.getResult = function() {
      return result;
    };
    EQP.setVar = function(variable, value) {
      return varMap[variable] = value;
    };
    EQP.getVar = function(variable) {
      return varMap[variable];
    };
    EQP.getUnitInfo = function(unit) {
      return unitMap[unit];
    };
    return EQP;
  })();

  /*
   * EQScanner - An Equation Token Scanner for Javascript
   * The Scanner module goes through the tokens, identifies them by their class
   *and saves a reference for future lookup 
   * @author Ben McCormick
  */


  window.EQScanner = (function() {
    var EQS, currentref, currenttok, errorHandle, funcs, isInSym, isUnit, nextToken, ops, puncs, setReference, sym, tokens, units, unops, vars;
    EQS = {};
    tokens = [];
    sym = [];
    currenttok = "x";
    currentref = null;
    vars = {};
    units = {};
    funcs = ["sqr(", "sqrt(", "log(", "ln(", "exp(", "floor(", "ceil(", "neg(", "rnd(", "sin(", "cos(", "tan(", "asin(", "acos(", "atan(", "abs(", "(", "min(", "max(", "perm(", "comb("];
    ops = ["+", "-", "*", "/", "^", "|", "&"];
    puncs = [",", ")", "#", "="];
    unops = ["!", "%"];
    EQS.init = function(varMap, unitMap) {
      vars = varMap;
      return units = unitMap;
    };
    EQS.newExpression = function(tokenarr) {
      return tokens = tokenarr.reverse();
    };
    EQS.scanNext = function() {
      var numx, tok, varx;
      tok = nextToken();
      if (tok == null) {
        return null;
      }
      numx = /^[\-+]?[0-9]*\.?[0-9]+$/;
      varx = /^[A-Za-z]+[0-9]*$/;
      currenttok = $.inArray(tok, funcs) !== -1 ? "f" : $.inArray(tok, ops) !== -1 ? "b" : $.inArray(tok, unops) !== -1 ? "u" : numx.exec(tok) ? "d" : $.inArray(tok, puncs) !== -1 ? tok : isUnit(tok) ? "n" : varx.exec(tok) ? "v" : errorHandle(tok);
      if (currenttok.indexOf("Error:" === -1)) {
        setReference(tok);
      }
      return {
        token: currenttok,
        ref: currentref
      };
    };
    EQS.hasTokens = function() {
      return tokens.length;
    };
    EQS.getRefData = function(index) {
      return sym[index];
    };
    EQS.getVar = function(varname) {
      return vars[varname];
    };
    EQS.setVar = function(varname, val) {
      return vars[varname] = val;
    };
    nextToken = function() {
      if (tokens.length) {
        return tokens.pop();
      } else {
        return null;
      }
    };
    errorHandle = function(tok) {
      return "Error: Invalid token - " + tokz;
    };
    setReference = function(tok) {
      var isDigit, isPunc;
      currentref = isInSym((tok + "").toLowerCase());
      isDigit = currenttok === "d";
      isPunc = puncs.indexOf(currenttok) > -1;
      if (currentref == null) {
        currentref = sym.length;
        return sym.push({
          symbol: currenttok,
          text: (tok + "").toLowerCase(),
          value: isDigit ? tok : isPunc ? null : "0"
        });
      }
    };
    isInSym = function(tok) {
      var i, symbol, _i, _len;
      for (i = _i = 0, _len = sym.length; _i < _len; i = ++_i) {
        symbol = sym[i];
        if (symbol.text === tok) {
          return i;
        }
      }
      return null;
    };
    isUnit = function(tok) {
      return __indexOf.call(units, tok) >= 0;
    };
    return EQS;
  })();

  /*
   * EQTokenizer - An Equation Tokenizer for Javascript
   * The Tokenizer module takes a string and splits it up into individual tokens
   * @author Ben McCormick
  */


  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.EQTokenizer = (function() {
    var EQT, addImplicitMultiplication, tokenlist, units;
    EQT = {};
    tokenlist = [];
    units = {};
    EQT.init = function(varMap, unitMap) {
      return units = unitMap != null ? unitMap : {};
    };
    EQT.tokenize = function(expression, getVar) {
      var ZERO, assignnext, funcres, funcx, last, newexpression, number, numres, numx, operx, opres, spaceres, spacex, unopres, unopx, varres, varx;
      tokenlist = [];
      numx = /^(-?\d+\.?\d*|^-?\.\d+)/;
      spacex = /^\s+/;
      operx = /^[\+\-\*\/!%\^&|,)\[\]#=]/;
      unopx = /^[!%]/;
      funcx = /^\w*\(/;
      varx = /^[a-zA-Z]+\d*[\:\-\'\?\.]?/;
      assignnext = /^\s*=/;
      ZERO = new NumberValue("0");
      while (expression.length > 0) {
        last = null;
        if (tokenlist.length > 0) {
          last = tokenlist[tokenlist.length - 1];
        }
        numres = numx.exec(expression);
        if (numres) {
          number = new NumberValue(numres[0]);
          expression = expression.substring(numres[0].length);
          if (number.compareTo(ZERO) <= 0 && (last != null) && (last === ")" || (numx.exec(last) != null) || (varx.exec(last) != null))) {
            tokenlist.push("-");
            tokenlist.push((numres[0] + "").substring(1) + "");
          } else {
            tokenlist.push(numres[0] + "");
          }
          continue;
        }
        spaceres = spacex.exec(expression);
        if (spaceres) {
          expression = expression.substring(spaceres[0].length);
          continue;
        }
        opres = operx.exec(expression);
        if (opres) {
          tokenlist.push(opres[0]);
          expression = expression.substring(opres[0].length);
          continue;
        }
        unopres = unopx.exec(expression);
        if (unopres) {
          tokenlist.push(unopres[0]);
          expression = expression.substring(unopres[0].length);
          continue;
        }
        funcres = funcx.exec(expression);
        if (funcres) {
          tokenlist.push(funcres[0]);
          expression = expression.substring(funcres[0].length);
          continue;
        }
        varres = varx.exec(expression);
        if (varres) {
          newexpression = expression.substring(varres[0].length);
          if ((getVar(varres[0]) != null) || units[varres[0]] || assignnext.exec(newexpression)) {
            tokenlist.push(varres[0]);
          }
          expression = newexpression;
          continue;
        }
        return false;
      }
      addImplicitMultiplication();
      return tokenlist;
    };
    EQT.getList = function() {
      return tokenlist;
    };
    addImplicitMultiplication = function() {
      var closer, i, opener, _i, _ref, _results;
      opener = /^[)\d\w]+$/;
      closer = /^[(\d\w]+$/;
      _results = [];
      for (i = _i = _ref = tokenlist.length - 2; _i >= 0; i = _i += -1) {
        if (opener.exec(tokenlist[i]) && closer.exec(tokenlist[i + 1])) {
          _results.push(tokenlist.splice(i + 1, 0, "*"));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    return EQT;
  })();

  /*
   * EQTreeBuilder - An Equation TreeBuilder for Javascript
   * 
   *
   * @author Ben McCormick
  */


  window.EQTreeBuilder = (function() {
    var BinOpNode, DigitNode, EQB, FuncNode, UnOpNode, VarNode, balanceTree, cline, createNode, cstate, ctok, eqStack, errors, factorial, handleEqStack, instr, loadConfigs, myScan, precision, prods, prodsteps, reduce, shifts, stack, table, terms;
    EQB = {};
    myScan = {};
    eqStack = [];
    stack = [];
    terms = [];
    table = [];
    prods = [];
    prodsteps = [];
    ctok = null;
    cstate = null;
    instr = null;
    root = null;
    precision = 20;
    errors = [];
    cline = null;
    EQB.init = function() {
      return loadConfigs();
    };
    EQB.process = function(scanner, currline) {
      var calculationException, errorcode, errorinfo, index;
      cline = currline;
      myScan = scanner;
      cstate = 0;
      stack = [];
      eqStack = [];
      index = -1;
      stack.push("0");
      ctok = myScan.scanNext();
      while (true) {
        index = terms.indexOf(ctok.token);
        if (index === -1) {
          if (ctok.token.charAt(ctok.token.length - 1 === "(")) {
            throw {
              message: "Function not found",
              type: "E"
            };
          } else {
            throw {
              message: "Unknown Token",
              type: "E"
            };
          }
        }
        instr = table[cstate][index];
        if ((instr == null) || instr.charAt(0) === "e" || instr === "") {
          errorcode = instr != null ? instr : "e00";
          errorinfo = errors[parseInt(errorcode.substring(1))];
          calculationException = {
            message: errorinfo.message,
            type: errorinfo.type,
            errorcode: errorcode
          };
          throw calculationException;
        }
        if (instr === "acc") {
          return balanceTree(eqStack.pop());
        }
        if (instr.charAt(0) === "s") {
          shifts(instr.substring(1), ctok.ref);
        } else if (instr.charAt(0) === "r") {
          reduce(instr.substring(1));
        } else {
          false;
        }
      }
    };
    EQB.setPrecision = function(prec) {
      return precision = prec;
    };
    shifts = function(level, ref) {
      stack.push(ctok);
      stack.push(cstate + "");
      if (ref !== -1 && (myScan.getRefData(ref).value != null)) {
        eqStack.push(createNode(ref));
      }
      cstate = instr.substring(1);
      ctok = myScan.scanNext();
      if (ctok === null) {
        return ctok = {
          token: "$"
        };
      }
    };
    reduce = function(level) {
      var column, cprod, finish, idx, start, _i;
      cprod = prods[level];
      handleEqStack(level);
      start = stack.length - 1;
      finish = stack.length - (2 * cprod.components.length);
      idx;
      for (idx = _i = start; _i >= finish; idx = _i += -1) {
        if (idx === finish + 1) {
          cstate = stack[idx];
        }
        stack.pop();
      }
      stack.push(cprod.result);
      stack.push(cstate);
      column = terms.indexOf(cprod.result);
      return cstate = table[cstate][column];
    };
    balanceTree = function(node) {
      var argnum, child, lchild, newlchild, newrchild, newroot, rchild, target, _i, _len, _ref, _ref1;
      if (node.numChildren === 0) {
        return node;
      } else if (node.type === "f") {
        argnum = node.numChildren;
        _ref = node.arglist;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          child = balanceTree(child);
        }
      } else if (node.numChildren === 1) {
        child = (_ref1 = node.child) != null ? _ref1 : node.arglist[0];
        if (node.child.priority < node.priority && node.priority !== 10) {
          newroot = node.child;
          target = node.child.rchild;
          newroot.rchild = node;
          node.child = target;
          return newroot;
        } else {
          node.setChild(balanceTree(node.child));
        }
      } else {
        node.setChildren(balanceTree(node.lchild), balanceTree(node.rchild));
        lchild = node.lchild;
        rchild = node.rchild;
        if (lchild.priority < node.priority) {
          newlchild = lchild.rchild;
          lchild.setChildren(lchild.lchild, node);
          node.lchild = newlchild;
          return lchild;
        }
        if (rchild.priority < node.priority) {
          newrchild = rchild.rchild;
          rchild.setChildren(node, rchild.rchild);
          node.rchild = newrchild;
          return rchild;
        }
      }
      return node;
    };
    handleEqStack = function(productionNum) {
      lchild;
      rchild;
      child;
      binOpNode;
      func;
      opNode;
      arglist;
      variable;
      var arglist, binOpNode, child, func, lchild, opNode, rchild, variable;
      switch (productionNum) {
        case "2":
          child = eqStack.pop();
          variable = eqStack.pop();
          variable.setValue(child.value());
          cline.setVar(variable.name, child.value());
          return eqStack.push(variable);
        case "3":
          rchild = eqStack.pop();
          binOpNode = eqStack.pop();
          lchild = eqStack.pop();
          binOpNode.setChildren(lchild, rchild);
          return eqStack.push(binOpNode);
        case "11":
          arglist = [];
          child = eqStack.pop();
          try {
            while (child.type !== "f") {
              arglist.push(child);
              child = eqStack.pop();
            }
          } catch (err) {
            throw {
              message: "Function not found",
              type: "E"
            };
          }
          func = child;
          func.setArgList(arglist);
          return eqStack.push(func);
        case "9":
          opNode = eqStack.pop();
          child = eqStack.pop();
          opNode.setChild(child);
          return eqStack.push(opNode);
      }
    };
    createNode = function(ref) {
      var lastnum, refval, varVal;
      refval = myScan.getRefData(ref);
      switch (refval.symbol) {
        case "f":
          return new FuncNode(refval);
        case "d":
          return new DigitNode(refval);
        case "v":
          varVal = cline.getVar(refval.text, true);
          return new VarNode(refval, varVal);
        case "u":
          return new UnOpNode(refval);
        case "n":
          lastnum = eqStack.pop();
          lastnum.value().setUnits(refval.text);
          return lastnum;
        case "b":
          return new BinOpNode(refval);
        default:
          return "";
      }
    };
    loadConfigs = function() {
      table = tablePlaceHolder.table;
      terms = tablePlaceHolder.terms;
      prods = tablePlaceHolder.productions;
      return errors = tablePlaceHolder.errors;
    };
    FuncNode = (function() {

      function FuncNode(ref) {
        var that;
        that = this;
        this.type = "f";
        this.name = ref.text;
        this.numChildren = 0;
        this.priority = 10;
        this.arglist = null;
        this.value = function() {
          var arg0, arg1, child1, child2, denominator, difference, fact1, fact2, numerator;
          arg0 = that.arglist[0];
          arg1 = that.arglist[1];
          switch (that.name) {
            case "sin(":
              return new NumberValue(Math.sin(arg0.value()), arg0.units);
            case "cos(":
              return new NumberValue(Math.cos(arg0.value()), arg0.units);
            case "tan(":
              return new NumberValue(Math.tan(arg0.value()), arg0.units);
            case "(":
              return arg0.value();
            case "max(":
              child1 = arg0.value();
              child2 = arg1.value();
              if (child1.compareTo(child2) > 0) {
                return child1;
              } else {
                return child2;
              }
              break;
            case "min(":
              child1 = arg0.value();
              child2 = arg1.value();
              if (child1.compareTo(child2) < 0) {
                return child1;
              } else {
                return child2;
              }
              break;
            case "perm(":
              numerator = factorial(arg0.value());
              difference = arg0.value().subtract(arg1.value());
              denominator = factorial(difference);
              return numerator.divide(denominator, precision, RoundingMode.DOWN());
            case "comb(":
              numerator = factorial(arg0.value());
              difference = arg0.value().subtract(arg1.value());
              fact1 = factorial(arg1.value());
              fact2 = factorial(difference);
              return numerator.divide(fact.multiply(fact2), precision, RoundingMode.DOWN());
            case "ceil(":
              return arg0.value().ceil();
            case "floor(":
              return arg0.value().floor();
            default:
              return new NumberValue(0);
          }
        };
      }

      FuncNode.prototype.toString = function() {
        return this.name + this.child.toString() + ")";
      };

      FuncNode.prototype.setArgList = function(arglist) {
        this.arglist = arglist;
        return this.numChildren = arglist.length;
      };

      return FuncNode;

    })();
    DigitNode = (function() {

      function DigitNode(ref) {
        this.type = "d";
        this.name = ref.value;
        this.numChildren = 0;
        this.val = new NumberValue(this.name);
        this.priority = 100;
      }

      DigitNode.prototype.value = function() {
        return this.val;
      };

      DigitNode.prototype.toString = function() {
        return this.name;
      };

      return DigitNode;

    })();
    VarNode = (function() {
      var varValue;

      varValue = null;

      function VarNode(ref, varVal) {
        this.type = "v";
        this.name = ref.text;
        this.numChildren = 0;
        varValue = varVal;
        this.priority = 90;
      }

      VarNode.prototype.value = function() {
        return varValue;
      };

      VarNode.prototype.toString = function() {
        return ref.text;
      };

      VarNode.prototype.setValue = function(value) {
        return varValue = value;
      };

      return VarNode;

    })();
    UnOpNode = (function() {

      function UnOpNode(ref) {
        this.type = "u";
        this.name = ref.text;
        this.numChildren = 1;
        this.priority = 6;
        this.child = null;
      }

      UnOpNode.prototype.toString = function() {
        return this.child.toString() + "" + this.name;
      };

      UnOpNode.prototype.setChild = function(cnode) {
        return this.child = cnode;
      };

      UnOpNode.prototype.value = function() {
        var node;
        switch (this.name) {
          case "!":
            return factorial(this.child.value());
          case "%":
            node = this.child.value().divide(new NumberValue("100"));
            node.isPercentage = true;
            return node;
          default:
            return null;
        }
      };

      return UnOpNode;

    })();
    BinOpNode = (function() {

      function BinOpNode(ref) {
        this.name = ref.text;
        switch (this.name) {
          case "+":
          case "-":
            this.priority = 0;
            break;
          case "*":
          case "/":
            this.priority = 5;
            break;
          default:
            this.priority = 5;
        }
        this.type = "b";
        this.numChildren = 2;
        this.lchild = null;
        this.rchild = null;
      }

      BinOpNode.prototype.value = function() {
        var isPercent, lnum, rnum, secondnum;
        isPercent = this.rchild.value().isPercentage;
        lnum = this.lchild.value();
        rnum = this.rchild.value();
        secondnum = isPercent ? rnum.multiply(lnum) : rnum;
        switch (this.name) {
          case "+":
            return lnum.add(secondnum);
          case "-":
            return lnum.subtract(secondnum);
          case "*":
            return lnum.multiply(rnum);
          case "/":
            return lnum.divide(rnum, this.precision, RoundingMode.HALF_DOWN());
          case "^":
            return lnum.pow(rnum);
        }
      };

      BinOpNode.prototype.toString = function() {
        return this.lchild.toString() + this.name + this.rchild.toString();
      };

      BinOpNode.prototype.setChildren = function(left, right) {
        this.lchild = left;
        return this.rchild = right;
      };

      return BinOpNode;

    })();
    factorial = function(val) {
      var i, num, _i;
      num = new NumberValue(1);
      for (i = _i = 0; _i <= val; i = _i += 1) {
        num = num.multiply(new NumberValue(i));
      }
      return num;
    };
    return EQB;
  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.NumberValue = (function() {

    function NumberValue(value, units, divisor) {
      this.units = units;
      this.num = new BigDecimal(value);
      this.divisor = divisor != null ? divisor : new BigDecimal(1);
    }

    NumberValue.prototype.setUnits = function(units) {
      this.units = units;
    };

    NumberValue.prototype.setValue = function(num) {
      this.num = num;
    };

    NumberValue.prototype.add = function(othernumber) {
      var nums, sum, _ref;
      nums = convertUnits(this, othernumber);
      sum = nums[0].num.add(nums[1].num);
      return new NumberValue(sum.toString(), (_ref = nums[0].units) != null ? _ref : nums[1].units, nums[0].divisor);
    };

    NumberValue.prototype.subtract = function(othernumber) {
      var difference, nums, _ref;
      nums = convertUnits(this, othernumber);
      difference = nums[0].num.subtract(nums[1].num);
      return new NumberValue(difference.toString(), (_ref = nums[0].units) != null ? _ref : nums[1].units, nums[0].divisor);
    };

    NumberValue.prototype.multiply = function(othernumber) {
      var denominator, numerator;
      numerator = this.num.multiply(othernumber.num);
      denominator = this.divisor.multiply(othernumber.divisor);
      return new NumberValue(numerator.toString(), this.units || othernumber.units, denominator);
    };

    NumberValue.prototype.divide = function(othernumber) {
      var denominator, numerator;
      numerator = this.num.multiply(othernumber.divisor);
      denominator = this.divisor.multiply(othernumber.num);
      return new NumberValue(numerator.toString(), this.units || othernumber.units, denominator);
    };

    NumberValue.prototype.pow = function(othernumber) {
      var i, newval, otherdiv, othernum, pow, _i;
      newval = new NumberValue(1, this.units);
      othernum = othernumber.num.floatValue();
      otherdiv = othernumber.divisor.floatValue();
      if ((othernum / otherdiv) % 1 === 0) {
        for (i = _i = 0; 0 <= othernum ? _i < othernum : _i > othernum; i = 0 <= othernum ? ++_i : --_i) {
          newval = newval.multiply(this);
        }
      } else {
        pow = Math.pow(this.num.floatValue(), othernum);
        newval = new NumberValue(pow, this.num.units);
      }
      return newval;
    };

    NumberValue.prototype.ceil = function() {
      var ceil, div, number;
      number = this.num.floatValue();
      div = this.divisor.floatValue();
      ceil = Math.ceil(number / div);
      this.num = new BigDecimal(ceil);
      this.divisor = new BigDecimal("1");
      return this;
    };

    NumberValue.prototype.floor = function() {
      var div, floor, number;
      number = this.num.floatValue();
      div = this.divisor.floatValue();
      floor = Math.floor(number / div);
      this.num = new BigDecimal(floor);
      this.divisor = new BigDecimal("1");
      return this;
    };

    NumberValue.prototype.compareTo = function(othernumber) {
      var nums, val1, val2;
      nums = convertUnits(this, othernumber);
      val1 = getDecimalVal(nums[0]);
      val2 = getDecimalVal(nums[1]);
      return val1.compareTo(val2);
    };

    NumberValue.prototype.toString = function() {
      var decVal, unitstr;
      unitstr = this.units != null ? " " + this.units : "";
      decVal = getDecimalVal(this).toString();
      return trimZeros(decVal) + unitstr;
    };

    return NumberValue;

  })();

  /*
  * Converts units for when units need to be synced up
  * If the units are the same type, but different value, it will work to convert 
  * them into the first unit
  * Also evens out the divisors
  */


  convertUnits = function(num1, num2) {
    var differentTypes, div1, info1, info2, multiple, sameunits;
    info1 = EQParser.getUnitInfo(num1.units);
    info2 = EQParser.getUnitInfo(num2.units);
    sameunits = num1.units === num2.units;
    differentTypes = (info1 != null ? info1.type : void 0) !== (info2 != null ? info2.type : void 0);
    if ((num1.units != null) && (num2.units != null) && !(sameunits || differentTypes)) {
      multiple = new BigDecimal((info1.multiple / info2.multiple) + "");
      num2.num = num2.num.divide(multiple, 20, RoundingMode.HALF_DOWN());
      num2.units = num1.units;
    }
    if (num1.divisor.compareTo(num2.divisor) !== 0) {
      div1 = num1.divisor;
      num1.divisor = num1.divisor.multiply(num2.divisor);
      num1.num = num1.num.multiply(num2.divisor);
      num2.divisor = num1.divisor;
      num2.num = num2.num.multiply(div1);
    }
    return [num1, num2];
  };

  trimZeros = function(numString) {
    numString = numString.replace(/(\.[0-9]*?)0+$/, "$1");
    numString = numString.replace(/\.$/, "");
    return numString;
  };

  getDecimalVal = function(number) {
    return number.num.divide(number.divisor, 20, RoundingMode.HALF_DOWN());
  };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.tablePlaceHolder = (function() {
    var errors, productions, table, terms, unitMap;
    table = [["s1", "", "", "", "", "", "", "", "", "", "", "", "", 2, "", ""], ["e02", "", "", "", "", "s5", "s6", "s7", "", "", "s8", "", "", "", 3, 4], ["", "", "", "", "", "", "", "", "", "", "", "acc", "", "", "", ""], ["r10", "r10", "r10", "", "r10", "", "", "", "s9", "r10", "", "", "", "", "", ""], ["s10", "", "", "", "s11", "", "", "", "", "s12", "", "", "", "", "", ""], ["", "", "", "", "", "", "s6", "", "", "", "s14", "", "", "", 13, ""], ["r6", "r6", "r6", "", "r6", "", "", "", "r6", "r6", "", "", "", "", "", ""], ["", "", "", "", "", "s5", "s6", "s7", "", "", "s14", "", 15, "", 3, 16], ["r7", "r7", "r7", "s17", "r7", "", "", "", "r7", "r7", "", "", "", "", "", ""], ["r12", "r12", "r12", "", "r12", "", "", "", "", "r12", "", "", "", "", "", ""], ["", "", "", "", "", "", "", "", "", "", "", "r1", "", "", "", ""], ["", "", "", "", "", "s5", "s6", "s7", "", "", "s14", "", "", "", 3, 18], ["r9", "r9", "r9", "", "r9", "", "", "", "", "", "r9", "", "", "", "", "", ""], ["r8", "r8", "r8", "", "r8", "", "", "", "", "r8", "", "", "", "", "", ""], ["r7", "r7", "r7", "", "r7", "", "", "", "r7", "r7", "", "", "", "", "", ""], ["", "s19", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ["e01", "r4", "s20", "", "s11", "", "", "", "", "s12", "", "", "", "", "", ""], ["", "", "", "", "", "s5", "s6", "s7", "", "", "s14", "", "", "", 3, 21], ["r3", "r3", "r3", "", "r3", "", "", "", "", "r3", "", "", "", "", "", ""], ["r11", "r11", "r11", "", "r11", "", "", "", "", "r11", "", "", "", "", "", ""], ["", "", "", "", "", "s5", "s6", "s7", "", "", "s14", "", "", "", 3, 22], ["s23", "", "", "", "s11", "", "", "", "", "s12", "", "", "", "", "", ""], ["e01", "r5", "e01", "", "s11", "", "", "", "", "s12", "", "", "", "", "", ""], ["", "", "", "", "", "", "", "", "", "", "", "r2", "", "", "", ""]];
    terms = ["#", ")", ",", "=", "b", "c", "d", "f", "n", "u", "v", "$", "A", "E", "N", "S"];
    productions = [
      {
        result: null,
        components: null
      }, {
        result: "E",
        components: ["#", "S", "#"]
      }, {
        result: "E",
        components: ["#", "v", "=", "S", "#"]
      }, {
        result: "S",
        components: ["S", "b", "S"]
      }, {
        result: "A",
        components: ["S"]
      }, {
        result: "A",
        components: ["S", ",", "S"]
      }, {
        result: "N",
        components: ["d"]
      }, {
        result: "N",
        components: ["v"]
      }, {
        result: "S",
        components: ["c", "N"]
      }, {
        result: "S",
        components: ["S", "u"]
      }, {
        result: "S",
        components: ["N"]
      }, {
        result: "S",
        components: ["f", "A", ")"]
      }, {
        result: "S",
        components: ["N", "n"]
      }
    ];
    errors = [
      {
        message: "Something went wrong",
        type: "W"
      }, {
        message: "Unmatched Parentheses",
        type: "E"
      }, {
        message: "No Input",
        type: "N"
      }, {
        message: "Invalid Input",
        type: "E"
      }
    ];
    /*
    unitMap = {dollars:{type:"currency",multiple:1},
        dollar:{type:"currency",multiple:1},
        quarter:{type:"currency",multiple:0.25},
        quarters:{type:"currency",multiple:0.25},
        cents:{type:"currency",multiple:0.01},
        cent:{type:"currency",multiple:0.01},
        pennies:{type:"currency",multiple:0.01},
        penny:{type:"currency",multiple:0.01},
        dimes:{type:"currency",multiple:0.1},
        dime:{type:"currency",multiple:0.1},
        nickels:{type:"currency",multiple:0.05},
        nickel:{type:"currency",multiple:0.05},
        pounds:{type:"weight",multiple:1}};
    */

    unitMap = {};
    return {
      table: table,
      terms: terms,
      productions: productions,
      errors: errors,
      units: unitMap
    };
  })();

}).call(this);
